// ğŸ” VARIÃVEL GLOBAL para controle de processamento
var EM_PROCESSAMENTO_AUTOMATICO = false;

// --- FUNÃ‡Ã•ES DE CONTROLE ---

// ğŸ¯ FUNÃ‡ÃƒO PRINCIPAL - PROCESSAMENTO DIÃRIO COMPLETO
function rodarProcessamentoDiario(CONFIG) {
    Logger.log("ğŸ§ª [LIB] processamentoDiarioCompletoPresencas INICIO");
    EM_PROCESSAMENTO_AUTOMATICO = true;
    
    try {
        // 1. Traz os dados brutos do formulÃ¡rio
        sincronizarRespostasFormulario(CONFIG);
        SpreadsheetApp.flush(); // Aguarda os dados aparecerem na planilha
        
        // 2. Extrai os IDs
        converterRespostasParaIds(CONFIG);
        SpreadsheetApp.flush(); // ForÃ§a a gravaÃ§Ã£o dos IDs antes da presenÃ§a ler
        
        // 3. VerificaÃ§Ãµes de status
        verificarReativacaoStatusPeloManual(CONFIG); 
        
        // 4. Marca P e F (Lendo agora da Coluna H, que estÃ¡ protegida)
        processarPresencasSemLimparManuais(CONFIG);
        
        // 5. Sincroniza correÃ§Ãµes manuais
        garantirPaginaCorrecoes(CONFIG);
        aplicarCorrecoesManuaisParaPagina1(CONFIG); 
        
        // 6. Atualiza a lista de alunos no formulÃ¡rio para a prÃ³xima aula
        atualizarFormularioPresencas(CONFIG);

        // 7. EstÃ©tica da presenÃ§a abonada
        aplicarFormatacaoAbonada(CONFIG);
        
        Logger.log("ğŸ‰ PROCESSAMENTO DIÃRIO CONCLUÃDO!");
    } catch (error) {
        Logger.log(`âŒ Erro: ${error.toString()}`);
    } finally {
        EM_PROCESSAMENTO_AUTOMATICO = false;
        Logger.log("ğŸ”š [LIB] processamentoDiarioCompletoPresencas â€” FIM");
    }
}

// ğŸ¯ CONFIGURAR MENU
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('ğŸ“ Sistema de PresenÃ§as')
    .addItem('ğŸ’¾ SALVAR CORREÃ‡Ã•ES MANUAIS', 'menuSalvarCorrecoes')
    .addToUi();
}

function menuSalvarCorrecoes() {
  const CONFIG = obterConfig();
  salvarCorrecoesManuaisPresencas(CONFIG, false);
}


// --- FUNÃ‡Ã•ES DE PROCESSAMENTO ---

// Aplica formataÃ§Ã£o condicional para 'A' (Abonada)
function aplicarFormatacaoAbonada(CONFIG) {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(CONFIG.ABAS.LISTA_ALUNOS);
    
    if (!sheet) return;

    const maxColumns = sheet.getLastColumn();
    const rangePresencas = sheet.getRange(2, 5, sheet.getLastRow() - 1, maxColumns - 4); 

    const rules = sheet.getConditionalFormatRules();
    const newRules = [];
    
    for (const rule of rules) {
        try {
            if (rule && rule.getCriteriaType) { 
                const criteria = rule.getCriteriaType();
                const values = rule.getCriteriaValues();

                if (criteria === SpreadsheetApp.BooleanCriteria.TEXT_EQUAL && values.length > 0 && values[0] === "A") {
                    continue;
                }
            }
        } catch(e) {
            Logger.log(`âš ï¸ Ignorando regra de formataÃ§Ã£o condicional invÃ¡lida: ${e.message}`);
            continue; 
        }
        
        // MantÃ©m todas as outras regras (vÃ¡lidas, 'D', 'F', etc.)
        newRules.push(rule);
    }
    
    // 2. CriaÃ§Ã£o da Regra 'A'
    const ruleA = SpreadsheetApp.newConditionalFormatRule()
Â  Â  Â  Â  .whenTextEqualTo("A")
Â  Â  Â  Â  .setBackground("#C9DAF8") 
Â  Â  Â  Â  .setRanges([rangePresencas])
Â  Â  Â  Â  .build();

    // 3. Aplica o conjunto de regras filtrado + a regra 'A'
    sheet.setConditionalFormatRules([...newRules, ruleA]);
    Logger.log("âœ… FormataÃ§Ã£o condicional para 'A' aplicada.");
}

// ğŸ”„ RECUPERAR STATUS PELO MANUAL
function verificarReativacaoStatusPeloManual(CONFIG) {
Â  const ss = SpreadsheetApp.getActiveSpreadsheet();
Â  const paginaPrincipal = ss.getSheetByName(CONFIG.ABAS.LISTA_ALUNOS);
Â  const paginaCorrecoes = ss.getSheetByName(CONFIG.ABAS.CORRECOES_MANUAIS);

Â  if (!paginaCorrecoes) return; 

Â  const dadosP1 = paginaPrincipal.getDataRange().getValues();
Â  const dadosP2 = paginaCorrecoes.getDataRange().getValues();

Â  // Mapear dados da P2
Â  const mapaStatusP2 = new Map();
Â  if (dadosP2.length > 1) {
Â  Â  for (let i = 1; i < dadosP2.length; i++) {
Â  Â  Â  const row = dadosP2[i];
Â  Â  Â  const id = String(row[0]).trim();
Â  Â  Â  // Coluna D (Ã­ndice 3) Ã© o Status
Â  Â  Â  const status = row[3] ? String(row[3]).trim().toLowerCase() : ""; 
Â  Â  Â  if (id) mapaStatusP2.set(id, status);
Â  Â  }
Â  }

Â  let recuperados = 0;

Â  for (let i = 1; i < dadosP1.length; i++) {
Â  Â  const row = dadosP1[i];
Â  Â  const id = String(row[0]).trim();
Â  Â  const statusP1 = row[3] ? String(row[3]).trim().toLowerCase() : "";
Â  Â  
Â  Â  if (!id) continue;

Â  Â  const statusP2 = mapaStatusP2.get(id);

Â  Â  // REGRA: Se P1 diz "Desistente" mas P2 diz "Cursando", P2 vence.
Â  Â  if ((statusP1 === "desistente" || statusP1 === "inativo") && 
Â  Â  Â  Â  (statusP2 === "cursando" || statusP2 === "ativo")) {
Â  Â  Â  
Â  Â  Â  // Atualiza P1 para "Cursando" imediatamente
Â  Â  Â  paginaPrincipal.getRange(i + 1, 4).setValue("Cursando"); 
Â  Â  Â  recuperados++;
Â  Â  }
Â  }
Â  
Â  // ForÃ§a salvar para que as prÃ³ximas funÃ§Ãµes jÃ¡ leiam o status novo
Â  if (recuperados > 0) SpreadsheetApp.flush(); 
}

// ğŸ“‹ GARANTIR E SINCRONIZAR A "PÃGINA 2"
function garantirPaginaCorrecoes(CONFIG) {
Â  const ss = SpreadsheetApp.getActiveSpreadsheet();
Â  const paginaPrincipal = ss.getSheetByName(CONFIG.ABAS.LISTA_ALUNOS);
Â  let paginaCorrecoes = ss.getSheetByName(CONFIG.ABAS.CORRECOES_MANUAIS);

Â  if (!paginaCorrecoes) {
Â  Â  Â  paginaCorrecoes = ss.insertSheet(CONFIG.ABAS.CORRECOES_MANUAIS);
Â  Â  Â  Logger.log(`âœ… Aba "${CONFIG.ABAS.CORRECOES_MANUAIS}" criada.`);
Â  }

Â  const dadosP1 = paginaPrincipal.getDataRange().getValues();
Â  if (dadosP1.length === 0) return;

Â  const dadosP2 = paginaCorrecoes.getDataRange().getValues();
Â  const timezone = Session.getScriptTimeZone();
Â  const normalizeHeader = (h) => h instanceof Date ? Utilities.formatDate(h, timezone, "dd/MM/yyyy") : String(h);

Â  // 1. Mapear todos os dados e cabeÃ§alhos existentes
Â  const cabecalhoP1 = dadosP1[0];
Â  const cabecalhoP2 = dadosP2.length > 0 ? dadosP2[0] : [];
Â  const mapaCabecalhoP1 = new Map(cabecalhoP1.map((h, i) => [normalizeHeader(h), i]));
Â  const mapaCabecalhoP2 = new Map(cabecalhoP2.map((h, i) => [normalizeHeader(h), i]));
Â  
Â  // Mapear dados da P2 por ID em vez de por posiÃ§Ã£o
Â  const mapaDadosP2PorId = new Map();
Â  if (dadosP2.length > 1) {
Â  Â  for (let i = 1; i < dadosP2.length; i++) {
Â  Â  Â  const idAluno = String(dadosP2[i][0]);
Â  Â  Â  if (idAluno) {
Â  Â  Â  Â  mapaDadosP2PorId.set(idAluno, dadosP2[i]);
Â  Â  Â  }
Â  Â  }
Â  }

Â  // 2. Construir o cabeÃ§alho mestre para a PÃ¡gina 2, SEM DUPLICATAS
Â  const cabecalhoFinalMap = new Map();
Â  
Â  // Adiciona as 4 colunas base (ID, Nome, Idade, Status)
Â  const colunasBase = cabecalhoP1.slice(0, 4);
Â  colunasBase.forEach((h, i) => {
Â  Â  cabecalhoFinalMap.set(normalizeHeader(h), h);
Â  });
Â  
Â  // Adiciona TODAS as colunas de data (da P1 e P2)
Â  const todasColunas = [...cabecalhoP1, ...cabecalhoP2];
Â  todasColunas.forEach(h => {
Â  Â  const headerStr = normalizeHeader(h);
Â  Â  // SÃ³ adiciona se nÃ£o for uma das colunas base (jÃ¡ adicionadas) e se nÃ£o for duplicata
Â  Â  if (!cabecalhoFinalMap.has(headerStr) && 
Â  Â  Â  Â  !['id', 'nome', 'idade', 'status'].includes(headerStr.toLowerCase())) {
Â  Â  Â  cabecalhoFinalMap.set(headerStr, h);
Â  Â  }
Â  });

Â  const cabecalhoFinal = Array.from(cabecalhoFinalMap.values());

Â  // 3. Construir a nova matriz de dados, garantindo consistÃªncia POR ID
Â  const novosDadosP2 = [];
Â  for (let i = 1; i < dadosP1.length; i++) {
Â  Â  Â  const linhaP1 = dadosP1[i];
Â  Â  Â  const idAluno = String(linhaP1[0]);
Â  Â  Â  if (!idAluno) continue;

Â  Â  Â  // Busca dados por ID em vez de por posiÃ§Ã£o
Â  Â  Â  const linhaAntigaP2 = mapaDadosP2PorId.get(idAluno);
Â  Â  Â  const novaLinha = new Array(cabecalhoFinal.length).fill("");

Â  Â  Â  cabecalhoFinal.forEach((h, j) => {
Â  Â  Â  Â  const headerStr = normalizeHeader(h);
Â  Â  Â  Â  const indiceAntigoP2 = mapaCabecalhoP2.get(headerStr);
Â  Â  Â  Â  const indiceP1 = mapaCabecalhoP1.get(headerStr);

Â  Â  Â  Â  // REGRA 1: Para colunas de STATUS (Ã­ndice 3), SEMPRE usar PÃ¡gina 1
Â  Â  Â  Â  if (j === 3) { // Coluna D Ã© Ã­ndice 3 (Status)
Â  Â  Â  Â  Â  if (indiceP1 !== undefined && linhaP1[indiceP1] !== undefined) {
Â  Â  Â  Â  Â  Â  novaLinha[j] = linhaP1[indiceP1];
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  // REGRA 2: Para colunas de DATA (a partir da coluna E, Ã­ndice 4), priorizar PÃ¡gina 2
Â  Â  Â  Â  else if (j >= 4) {
Â  Â  Â  Â  Â  // Priorizar correÃ§Ãµes manuais da PÃ¡gina 2
Â  Â  Â  Â  Â  if (linhaAntigaP2 && indiceAntigoP2 !== undefined && linhaAntigaP2[indiceAntigoP2] !== "") {
Â  Â  Â  Â  Â  Â  Â  novaLinha[j] = linhaAntigaP2[indiceAntigoP2];
Â  Â  Â  Â  Â  } 
Â  Â  Â  Â  Â  // Se nÃ£o hÃ¡ correÃ§Ã£o, usar valor da PÃ¡gina 1
Â  Â  Â  Â  Â  else if (indiceP1 !== undefined && linhaP1[indiceP1] !== undefined) {
Â  Â  Â  Â  Â  Â  Â  novaLinha[j] = linhaP1[indiceP1];
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  // REGRA 3: Para outras colunas (ID, Nome, Idade), sempre PÃ¡gina 1
Â  Â  Â  Â  else {
Â  Â  Â  Â  Â  if (indiceP1 !== undefined && linhaP1[indiceP1] !== undefined) {
Â  Â  Â  Â  Â  Â  Â  novaLinha[j] = linhaP1[indiceP1];
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  Â  
Â  Â  Â  // Garante que o ID esteja na primeira coluna
Â  Â  Â  novaLinha[0] = idAluno;
Â  Â  Â  novosDadosP2.push(novaLinha);
Â  }

Â  // 4. Limpa a "PÃ¡gina 2" e escreve os dados atualizados
Â  if (cabecalhoFinal.length > 0) {
Â  Â  paginaCorrecoes.clear();
Â  Â  paginaCorrecoes.getRange(1, 1, 1, cabecalhoFinal.length).setValues([cabecalhoFinal]);
Â  }
Â  if (novosDadosP2.length > 0) {
Â  Â  paginaCorrecoes.getRange(2, 1, novosDadosP2.length, cabecalhoFinal.length).setValues(novosDadosP2);
Â  }
Â  
Â  Logger.log(`âœ… Aba "${CONFIG.ABAS.CORRECOES_MANUAIS}" sincronizada. Status da P1, PresenÃ§as da P2.`);
}

// ğŸ“‹ SINCRONIZAR RESPOSTAS DO FORMULÃRIO
function sincronizarRespostasFormulario(CONFIG) {
Â  const ss = SpreadsheetApp.getActiveSpreadsheet();
Â  const formSheet = ss.getSheetByName(CONFIG.ABAS.RESPOSTAS_FORM);

Â  if (!formSheet) {
Â  Â  Logger.log(`âŒ A aba de respostas do formulÃ¡rio "${CONFIG.ABAS.RESPOSTAS_FORM}" nÃ£o foi encontrada. Verifique se o formulÃ¡rio estÃ¡ corretamente vinculado a esta planilha.`);
Â  Â  throw new Error(`Aba de respostas "${CONFIG.ABAS.RESPOSTAS_FORM}" nÃ£o encontrada.`);
Â  }

Â  Logger.log(`âœ… Aba de respostas "${CONFIG.ABAS.RESPOSTAS_FORM}" encontrada.`);
}

// ğŸ”„ CONVERTER NOMES PARA IDs
function converterRespostasParaIds(CONFIG) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const formSheet = ss.getSheetByName(CONFIG.ABAS.RESPOSTAS_FORM);
  
  if (!formSheet) {
    Logger.log("âŒ Erro: Aba de respostas nÃ£o encontrada.");
    return;
  }

  const formData = formSheet.getDataRange().getValues();
  // Coluna F (5) Ã© onde chega os dados do Form ("101 - JoÃ£o")
  const colOriginal = CONFIG.COLUNAS_FORMULARIO.ALUNOS_PRESENTES; 
  // Coluna H (7) Ã© onde guarda apenas os IDs ("101")
  const colDestino = 7; 

  let atualizacoes = 0;

  for (let i = 1; i < formData.length; i++) {
    const respostaRaw = formData[i][colOriginal];
    
    if (!respostaRaw || respostaRaw.toString().trim() === "") {
      continue;
    }

    // Processa a lista de nomes/IDs
    const itens = respostaRaw.toString().split(",");
    
    const idsValidos = itens.map(item => {
      let texto = item.trim();
      // Se o formato for "ID - Nome", extraÃ­mos apenas o ID antes do hÃ­fen
      if (texto.includes(" - ")) {
        return texto.split(" - ")[0].trim();
      }
      // Se nÃ£o tiver hÃ­fen, assume que jÃ¡ Ã© o ID puro
      return texto;
    }).filter(id => id !== "" && id.toLowerCase() !== "turma vazia (todos faltaram)");

    // Grava o resultado na Coluna H
    // Usamos a coluna H (que Ã© uma coluna a parte) porque o Google Forms nÃ£o sobrescreve ela na sincronizaÃ§Ã£o
    if (idsValidos.length > 0) {
      formSheet.getRange(i + 1, colDestino + 1).setValue(idsValidos.join(", "));
      atualizacoes++;
    } else {
      // Se for "Turma Vazia", deixamos a cÃ©lula de ID limpa para marcar falta em todos
      formSheet.getRange(i + 1, colDestino + 1).setValue("");
    }
  }

  // ForÃ§a o Google Sheets a salvar as alteraÃ§Ãµes
  SpreadsheetApp.flush();
  Logger.log(`âœ… IDs extraÃ­dos e protegidos na Coluna H: ${atualizacoes} linhas processadas.`);
}

// ğŸ“Š PROCESSAR PRESENÃ‡AS
function processarPresencasSemLimparManuais(CONFIG) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const listaSheet = ss.getSheetByName(CONFIG.ABAS.LISTA_ALUNOS);
  const formSheet = ss.getSheetByName(CONFIG.ABAS.RESPOSTAS_FORM);

  if (!formSheet || !listaSheet) return;

  const listaData = listaSheet.getDataRange().getValues();
  const formData = formSheet.getDataRange().getValues();
  const headerLista = listaData[0];
  const timezone = Session.getScriptTimeZone();

  const normalizarData = (d) => {
    if (!d) return null;

    const dataObj = (d instanceof Date) ? d : new Date(d);

    if (isNaN(dataObj.getTime()) || dataObj.getFullYear() === 1969) {
      return null;
    }

    return Utilities.formatDate(dataObj, timezone, "dd/MM/yyyy");
  };


  const mapaAlunos = {};
  
  // 1. Mapear IDs da PÃ¡gina1
  for (let i = 1; i < listaData.length; i++) {
    const idOriginal = listaData[i][0];
    if (idOriginal !== "") {
      const idStr = idOriginal.toString().trim();
      mapaAlunos[idStr] = { 
        linhaIndex: i, 
        status: listaData[i][3] ? listaData[i][3].toString().trim().toLowerCase() : "", 
        dataPrimeiraDesistencia: null,
        contemD: false
      };
      
      // Busca data de desistÃªncia
      for (let j = 4; j < listaData[i].length; j++) {
        if (String(listaData[i][j]).toUpperCase() === "D") {
          mapaAlunos[idStr].contemD = true;
          mapaAlunos[idStr].dataPrimeiraDesistencia = normalizarData(headerLista[j]);
          break;
        }
      }
    }
  }

  // 2. Processar Respostas do Form
  for (let i = 1; i < formData.length; i++) {
    const dataAulaRaw = formData[i][CONFIG.COLUNAS_FORMULARIO.DATA_AULA];
    const idsPresentesRaw = formData[i][CONFIG.COLUNAS_FORMULARIO.IDS_PRESENTES];
    
    if (!dataAulaRaw) continue;

    const dataAulaFormatada = normalizarData(dataAulaRaw);
    if (!dataAulaFormatada) {
        continue;
    }

    const dataAulaObj = new Date(dataAulaRaw);

    
    // IDs vindos do Form (jÃ¡ sÃ£o IDs, apenas limpamos)
    const idsPresentes = idsPresentesRaw ? 
      idsPresentesRaw.toString().split(",").map(id => id.trim()) : [];

    // Localizar coluna da data
    let colPresenca = -1;
    let atualHeader = listaSheet.getRange(1, 1, 1, listaSheet.getLastColumn()).getValues()[0];
    for (let j = 4; j < atualHeader.length; j++) {
      if (normalizarData(atualHeader[j]) === dataAulaFormatada) {
        colPresenca = j + 1;
        break;
      }
    }

    if (colPresenca === -1) {
      colPresenca = listaSheet.getLastColumn() + 1;
      listaSheet.getRange(1, colPresenca).setValue(dataAulaFormatada);
    }

    // 4. Marcar P, F ou D
    for (const id in mapaAlunos) {
      const aluno = mapaAlunos[id];
      const celula = listaSheet.getRange(aluno.linhaIndex + 1, colPresenca);
      const valorAtual = celula.getValue().toString().toUpperCase();

      if (valorAtual === "A" || valorAtual === "D") continue;

      // Se o ID do aluno estÃ¡ na lista de IDs que o Form enviou
      let novoValor = idsPresentes.includes(id) ? "P" : "F";

      // LÃ³gica do Desistente
      if (aluno.status === "desistente" && aluno.dataPrimeiraDesistencia) {
        const partes = aluno.dataPrimeiraDesistencia.split('/');
        const dataDesist = new Date(partes[2], partes[1] - 1, partes[0]);
        if (dataAulaObj.setHours(0,0,0,0) >= dataDesist.setHours(0,0,0,0)) novoValor = "D";
      }

      if (valorAtual !== novoValor) celula.setValue(novoValor);
    }
  }
  Logger.log("âœ… Processamento concluÃ­do sem erros de conversÃ£o.");
}

// APLICA CORREÃ‡Ã•ES MANUAIS (P2 -> P1), PROPAGA 'D' E SINCRONIZA STATUS
function aplicarCorrecoesManuaisParaPagina1(CONFIG) {
Â  Â  const ss = SpreadsheetApp.getActiveSpreadsheet();
Â  Â  const paginaPrincipal = ss.getSheetByName(CONFIG.ABAS.LISTA_ALUNOS);
Â  Â  const paginaCorrecoes = ss.getSheetByName(CONFIG.ABAS.CORRECOES_MANUAIS);
Â  Â  
Â  Â  if (!paginaCorrecoes) return;
Â  Â  
Â  Â  // Leitura Inicial dos Dados da P1 e P2
Â  Â  let dadosP1 = paginaPrincipal.getDataRange().getValues();
Â  Â  const dadosP2 = paginaCorrecoes.getDataRange().getValues();
Â  Â  
Â  Â  if (dadosP2.length <= 1) return;
Â  Â  
Â  Â  // --- 1. CONFIGURAÃ‡ÃƒO DE MAPAS ---
Â  Â  const cabecalhoP1 = dadosP1[0];
Â  Â  const mapaColunasP1 = new Map();
Â  Â  cabecalhoP1.forEach((h, i) => { if (i >= 4) mapaColunasP1.set(String(h), i); });
Â  Â  
Â  Â  let correcoesAplicadas = 0;

Â  Â  // =========================================================================
Â  Â  // PASSAGEM 1: Aplicar Apenas CorreÃ§Ãµes Manuais (P2 -> P1)
Â  Â  // Objetivo: Garantir que o novo 'D' do usuÃ¡rio seja escrito na P1.
Â  Â  // =========================================================================
Â  Â  
Â  Â  const mapaAlunosP1_Inicial = new Map();
Â  Â  for (let i = 1; i < dadosP1.length; i++) {
Â  Â  Â  Â  const idAluno = String(dadosP1[i][0]);
Â  Â  Â  Â  if (idAluno) mapaAlunosP1_Inicial.set(idAluno, { linha: dadosP1[i], index: i });
Â  Â  }

Â  Â  for (let i = 1; i < dadosP2.length; i++) {
Â  Â  Â  Â  const linhaP2 = dadosP2[i];
Â  Â  Â  Â  const idAluno = String(linhaP2[0]);
Â  Â  Â  Â  if (!idAluno) continue;
Â  Â  Â  Â  
Â  Â  Â  Â  const alunoP1 = mapaAlunosP1_Inicial.get(idAluno);
Â  Â  Â  Â  if (!alunoP1) continue;
Â  Â  Â  Â  
Â  Â  Â  Â  const indexP1 = alunoP1.index;
Â  Â  Â  Â  
Â  Â  Â  Â  for (let j = 4; j < linhaP2.length; j++) {
Â  Â  Â  Â  Â  Â  const dataKey = String(dadosP2[0][j]);
Â  Â  Â  Â  Â  Â  const colP1 = mapaColunasP1.get(dataKey);
Â  Â  Â  Â  Â  Â  if (colP1 === undefined) continue;

Â  Â  Â  Â  Â  Â  const valorP2 = linhaP2[j] ? linhaP2[j].toString().trim().toUpperCase() : "";
Â  Â  Â  Â  Â  Â  const valorP1 = alunoP1.linha[colP1] ? alunoP1.linha[colP1].toString().trim().toUpperCase() : "";
Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  // Ignora Status
Â  Â  Â  Â  Â  Â  if (colP1 === 3) continue;

Â  Â  Â  Â  Â  Â  // REGRA: Aplica CorreÃ§Ã£o Manual (P2 -> P1)
Â  Â  Â  Â  Â  Â  if (valorP2 !== "" && valorP2 !== valorP1) {
Â  Â  Â  Â  Â  Â  Â  Â  paginaPrincipal.getRange(indexP1 + 1, colP1 + 1).setValue(valorP2);
Â  Â  Â  Â  Â  Â  Â  Â  correcoesAplicadas++;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  }
Â  Â  
Â  Â  // SINCRONIZAÃ‡ÃƒO CRÃTICA: OBRIGATÃ“RIA PARA RE-LER O NOVO 'D'
Â  Â  if (correcoesAplicadas > 0) {
Â  Â  Â  Â  SpreadsheetApp.flush();
Â  Â  Â  Â  dadosP1 = paginaPrincipal.getDataRange().getValues(); 
Â  Â  Â  Â  Logger.log(`Passagem 1 concluÃ­da: ${correcoesAplicadas} correÃ§Ãµes manuais aplicadas Ã  P1.`);
Â  Â  }

Â  Â  // =========================================================================
Â  Â  // PASSAGEM 2: PropagaÃ§Ã£o de 'D' e SincronizaÃ§Ã£o Final de Status
Â  Â  // =========================================================================
Â  Â  
Â  Â  let propagacoesD = 0;
Â  Â  let statusAtualizadosP1 = 0;
Â  Â  
Â  Â  // Percorre a P1 atualizada
Â  Â  for (let i = 1; i < dadosP1.length; i++) {
Â  Â  Â  Â  const linha = dadosP1[i];
Â  Â  Â  Â  const id = linha[0] ? linha[0].toString().trim() : null;
Â  Â  Â  Â  if (!id) continue;

Â  Â  Â  Â  const statusAtual = linha[3] ? linha[3].toString().trim().toLowerCase() : "";
Â  Â  Â  Â  const linhaIndex = i + 1; // Linha 1-based na planilha

Â  Â  Â  Â  // 1. Encontra a coluna do PRIMEIRO 'D'
Â  Â  Â  Â  let colunaPrimeiraDesistencia = -1;
Â  Â  Â  Â  for (let j = 4; j < linha.length; j++) {
Â  Â  Â  Â  Â  Â  if (String(linha[j]).trim().toUpperCase() === "D") {
Â  Â  Â  Â  Â  Â  Â  Â  colunaPrimeiraDesistencia = j;
Â  Â  Â  Â  Â  Â  Â  Â  break; // Para na primeira ocorrÃªncia (o 'D' mais antigo)
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  const contemD = (colunaPrimeiraDesistencia !== -1);
Â  Â  Â  Â  

Â  Â  Â  Â  // FLUXO LÃ“GICO: A presenÃ§a de D agora DISPARA ambas as aÃ§Ãµes
Â  Â  Â  Â  if (contemD) {

Â  Â  Â  Â  Â  Â  // 2A. PROPAGAÃ‡ÃƒO DE 'D'
Â  Â  Â  Â  Â  Â  for (let j = colunaPrimeiraDesistencia; j < linha.length; j++) {
Â  Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  Â  const valorP1 = String(linha[j]).trim().toUpperCase();

Â  Â  Â  Â  Â  Â  Â  Â  // Se a cÃ©lula nÃ£o for 'D', forÃ§amos para 'D'.
Â  Â  Â  Â  Â  Â  Â  Â  if (valorP1 !== "D") { 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  paginaPrincipal.getRange(linhaIndex, j + 1).setValue("D");
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  propagacoesD++;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
            
Â  Â  Â  Â  Â  Â  // 2B. SINCRONIZAÃ‡ÃƒO DE STATUS (Se tem D, Status = Desistente)
Â  Â  Â  Â  Â  Â  if (statusAtual === "cursando" || statusAtual === "ativo") {
Â  Â  Â  Â  Â  Â  Â  Â  paginaPrincipal.getRange(linhaIndex, 4).setValue("Desistente");
Â  Â  Â  Â  Â  Â  Â  Â  statusAtualizadosP1++;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  } 
        // 3. Regra de ReversÃ£o de Status: Se nÃ£o tem D, mas estÃ¡ Desistente (volta para Cursando)
        else if (!contemD && (statusAtual === "desistente" || statusAtual === "inativo")) {
Â  Â  Â  Â  Â  Â  paginaPrincipal.getRange(linhaIndex, 4).setValue("Cursando");
Â  Â  Â  Â  Â  Â  statusAtualizadosP1++;
Â  Â  Â  Â  }
Â  Â  }

Â  Â  if (propagacoesD > 0 || statusAtualizadosP1 > 0) {
Â  Â  Â  Â  SpreadsheetApp.flush(); 
Â  Â  Â  Â  Logger.log(`Passagem 2 concluÃ­da: ${propagacoesD} propagacÃµes 'D' e ${statusAtualizadosP1} status sincronizados.`);
Â  Â  }
}

function atualizarFormularioPresencas(CONFIG) {
  const sheet = SpreadsheetApp.getActiveSpreadsheet().getSheetByName(CONFIG.ABAS.LISTA_ALUNOS);
  if (!sheet) return;
  
  const data = sheet.getRange("A2:D" + sheet.getLastRow()).getValues()
    .filter(r => r[0] && r[1] && r[3] && 
               (r[3].toString().trim().toLowerCase() === "cursando" || 
                r[3].toString().trim().toLowerCase() === "ativo"));

  const alunosUnicos = [];
  const idsVistos = new Set();
  
  if (data.length > 0) {
    for (const aluno of data) {
      const id = aluno[0].toString().trim();
      const nome = aluno[1].toString().trim();
      if (!idsVistos.has(id)) {
        idsVistos.add(id);
        // FORMATO: "ID - Nome" para o script conseguir separar depois
        alunosUnicos.push(`${id} - ${nome}`);
      }
    }
  }

  const form = FormApp.openById(CONFIG.FORM_ID);
  const items = form.getItems();
  let pergunta = null;

  for (let item of items) {
    if (item.getTitle().toLowerCase().includes("alunos presentes")) {
      pergunta = item.asCheckboxItem();
      break;
    }
  }

  if (pergunta) {
    let choices = alunosUnicos.map(texto => pergunta.createChoice(texto));
    choices.push(pergunta.createChoice("âŒ Turma vazia (todos faltaram)"));
    pergunta.setChoices(choices);
    Logger.log(`âœ… FormulÃ¡rio atualizado com formato ID - Nome.`);
  }
}

// --- FUNÃ‡Ã•ES MANUAIS E DE MANUTENÃ‡ÃƒO ---

// ğŸ’¾ SALVAR CORREÃ‡Ã•ES MANUAIS
function salvarCorrecoesManuaisPresencas(CONFIG, skipUI = false) {
Â  if (EM_PROCESSAMENTO_AUTOMATICO) {
Â  Â  Logger.log("ğŸš« Ignorando salvamento durante processamento automÃ¡tico");
Â  Â  return;
Â  }

Â  const ss = SpreadsheetApp.getActiveSpreadsheet();
Â  const ui = SpreadsheetApp.getUi();
Â  const usuario = Session.getActiveUser().getEmail() || Session.getActiveUser().getEffectiveUser().getEmail() || "UsuÃ¡rio Desconhecido";
Â  const agora = new Date();
Â  
Â  const paginaPrincipal = ss.getSheetByName(CONFIG.ABAS.LISTA_ALUNOS);
Â  const paginaCorrecoes = ss.getSheetByName(CONFIG.ABAS.CORRECOES_MANUAIS);

Â  if (!paginaCorrecoes) {
Â  Â  if (!skipUI) ui.alert('Aba de CorreÃ§Ãµes Inexistente', `A aba "${CONFIG.ABAS.CORRECOES_MANUAIS}" nÃ£o foi encontrada. Sincronize os dados primeiro rodando o "Processamento DiÃ¡rio".`, ui.ButtonSet.OK);
Â  Â  return;
Â  }
Â  Â  
Â  // Lemos os dados UMA VEZ.
Â  const dadosPagina1 = paginaPrincipal.getDataRange().getValues();
Â  const dadosPagina2 = paginaCorrecoes.getDataRange().getValues();
Â  
Â  // Mapear dados da P2 por ID para busca rÃ¡pida
Â  const mapaPagina2PorId = new Map();
Â  if (dadosPagina2.length > 1) {
Â  Â  for (let i = 1; i < dadosPagina2.length; i++) {
Â  Â  Â  const idAluno = String(dadosPagina2[i][0]);
Â  Â  Â  if (idAluno) {
Â  Â  Â  Â  mapaPagina2PorId.set(idAluno, dadosPagina2[i]);
Â  Â  Â  }
Â  Â  }
Â  }

Â  const alteracoes = [];
Â  const cabecalho = dadosPagina1[0];
Â  
Â  // 1. Encontra e registra as correÃ§Ãµes na PÃ¡gina 2
Â  for (let i = 1; i < dadosPagina1.length; i++) {
Â  Â  const linha1 = dadosPagina1[i];
Â  Â  const id = linha1[0] ? linha1[0].toString() : '';
Â  Â  if (!id) continue;
Â  Â  
Â  Â  const statusAluno = linha1[3] ? linha1[3].toString().trim().toLowerCase() : "";
Â  Â  const isDesistente = (statusAluno === "desistente" || statusAluno === "inativo");
Â  Â  
Â  Â  // Encontra a data da primeira desistÃªncia (D) na P1
Â  Â  let dataPrimeiraDesistencia = null;
Â  Â  for (let j = 4; j < linha1.length; j++) {
Â  Â  Â  if (linha1[j] === "D" && !dataPrimeiraDesistencia) {
Â  Â  Â  Â  dataPrimeiraDesistencia = cabecalho[j];
Â  Â  Â  Â  break;
Â  Â  Â  }
Â  Â  }
Â  Â  
Â  Â  const linha2 = mapaPagina2PorId.get(id);

Â  Â  if (linha2) {
Â  Â  Â  for (let j = 4; j < linha1.length; j++) {
Â  Â  Â  Â  const val1 = linha1[j] ? linha1[j].toString().trim().toUpperCase() : "";
Â  Â  Â  Â  const val2 = linha2[j] ? linha2[j].toString().trim().toUpperCase() : "";
Â  Â  Â  Â  
Â  Â  Â  Â  // Coluna Status: Sempre P1 na P2
Â  Â  Â  Â  if (j === 3) {
Â  Â  Â  Â  Â  linha2[3] = linha1[3];
Â  Â  Â  Â  Â  continue;
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  // TRATAMENTO CONDICIONAL DE DESISTENTE (Limpa correÃ§Ã£o manual na P2, se deve ser 'D')
Â  Â  Â  Â  if (isDesistente) {
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  let deveSerD = false;
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  // LÃ³gica de checagem se a data deve ser 'D'
Â  Â  Â  Â  Â  if (dataPrimeiraDesistencia) {
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  const dataColunaObj = new Date(cabecalho[j].split(' ')[0]);
Â  Â  Â  Â  Â  Â  Â  const dataDObj = new Date(dataPrimeiraDesistencia.split(' ')[0]);
Â  Â  Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  Â  if (dataColunaObj.setHours(0, 0, 0, 0) >= dataDObj.setHours(0, 0, 0, 0)) {
Â  Â  Â  Â  Â  Â  Â  Â  deveSerD = true;
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  deveSerD = false;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  } 

Â  Â  Â  Â  Â  if (deveSerD) {
Â  Â  Â  Â  Â  Â  // Se P1 estiver diferente de 'D', registra a alteraÃ§Ã£o
Â  Â  Â  Â  Â  Â  if (val1 !== "D") {
Â  Â  Â  Â  Â  Â  Â  alteracoes.push({ 
Â  Â  Â  Â  Â  Â  Â  Â  id: id, nome: linha1[1], data: cabecalho[j], de: val1, para: "D", 
Â  Â  Â  Â  Â  Â  Â  Â  linha: i + 1, coluna: j + 1, colIndexP2: j 
Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  // LIMPA A CORREÃ‡ÃƒO MANUAL NA P2 FORÃ‡ANDO 'D' (P2 deve ser o valor correto)
Â  Â  Â  Â  Â  Â  if (val2 !== "D") {
Â  Â  Â  Â  Â  Â  Â  linha2[j] = "D"; 
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  continue; 
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  // REGRA NORMAL: Sincroniza P1 com P2 (registra a correÃ§Ã£o do usuÃ¡rio em P2)
Â  Â  Â  Â  if (val1 !== val2) {
Â  Â  Â  Â  Â  // Registra a alteraÃ§Ã£o que o usuÃ¡rio quer: DE P1 (val1) PARA P2 (val2)
Â  Â  Â  Â  Â  alteracoes.push({ 
Â  Â  Â  Â  Â  Â  id: id, nome: linha1[1], data: cabecalho[j], de: val1, para: val2, 
Â  Â  Â  Â  Â  Â  linha: i + 1, coluna: j + 1, colIndexP2: j 
Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  // P2 Ã© atualizado para conter o valor corrigido (val2)
Â  Â  Â  Â  Â  linha2[j] = val2; 
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â  mapaPagina2PorId.set(id, linha2);
Â  Â  }
Â  }

Â  if (alteracoes.length === 0) {
Â  Â  if (!skipUI) ui.alert('â„¹ï¸ Nenhuma AlteraÃ§Ã£o', 'Nenhuma alteraÃ§Ã£o manual foi detectada.', ui.ButtonSet.OK);
Â  Â  return;
Â  }
Â  
Â  // 2. ConstrÃ³i e escreve os novos dados na PÃ¡gina 2 (Corrige a P2)
Â  const novosDadosPagina2 = [dadosPagina2[0]]; 
Â  
Â  for (let i = 1; i < dadosPagina1.length; i++) {
Â  Â  const id = String(dadosPagina1[i][0]);
Â  Â  if (!id) continue;
Â  Â  
Â  Â  let linhaAtualizada = mapaPagina2PorId.get(id);
Â  Â  
Â  Â  if (linhaAtualizada) {
Â  Â  Â  linhaAtualizada[0] = dadosPagina1[i][0];
Â  Â  Â  linhaAtualizada[1] = dadosPagina1[i][1];
Â  Â  Â  linhaAtualizada[2] = dadosPagina1[i][2];
Â  Â  Â  linhaAtualizada[3] = dadosPagina1[i][3]; 
Â  Â  Â  Â  
Â  Â  Â  novosDadosPagina2.push(linhaAtualizada);
Â  Â  }
Â  }
Â  
Â  if (novosDadosPagina2.length > 0 && novosDadosPagina2[0].length > 0) {
Â  Â  // Limpa e reescreve a P2
Â  Â  paginaCorrecoes.getRange(1, 1, novosDadosPagina2.length, novosDadosPagina2[0].length).setValues(novosDadosPagina2);
Â  }

Â  SpreadsheetApp.flush(); 

Â  // 3. Adiciona o histÃ³rico de correÃ§Ãµes como comentÃ¡rio (utiliza os dados de alteracoes)
Â  const timezonePlanilha = ss.getSpreadsheetTimeZone();
Â  for (const alt of alteracoes) {
    const dataHoraFormatada = Utilities.formatDate(agora, timezonePlanilha, "dd/MM/yyyy HH:mm:ss");
Â  Â  
Â  Â  let linhaP2 = -1;
Â  Â  for (let i = 1; i < novosDadosPagina2.length; i++) {
Â  Â  Â  if (String(novosDadosPagina2[i][0]) === alt.id) {
Â  Â  Â  Â  linhaP2 = i + 1;
Â  Â  Â  Â  break;
Â  Â  Â  }
Â  Â  }
Â  Â  
Â  Â  if (linhaP2 !== -1) {
Â  Â  Â  const celulaCorrecao = paginaCorrecoes.getRange(linhaP2, alt.coluna);
Â  Â  Â  const historicoAntigo = celulaCorrecao.getComment() || "";
Â  Â  Â  
Â  Â  Â  let novoComentario = `[${dataHoraFormatada} por ${usuario}]\n`;
Â  Â  Â  novoComentario += `CorreÃ§Ã£o: ${alt.de} â†’ ${alt.para}\n`;
Â  Â  Â  
Â  Â  Â  if (historicoAntigo) {
Â  Â  Â  Â  novoComentario += '\n--- HistÃ³rico Anterior ---\n' + historicoAntigo;
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  celulaCorrecao.setComment(novoComentario);
Â  Â  }
Â  }

Â  // 4. Aplica as correÃ§Ãµes de volta para a PÃ¡gina 1 e SINCRONIZA O STATUS.
Â  aplicarCorrecoesManuaisParaPagina1(CONFIG);

// 5. ATUALIZA O STATUS DA PÃGINA 2 COM O NOVO STATUS FINAL DA PÃGINA 1
Â  const dadosP1Finais = paginaPrincipal.getDataRange().getValues();
Â  const numLinhas = dadosP1Finais.length - 1; // Excluindo o cabeÃ§alho
Â  const linhaInicial = 2; // ComeÃ§a na linha 2

Â  if (numLinhas > 0) {
Â  Â  // Range de Status na P1 (Linha 2, Coluna 4, NumLinhas, 1 Coluna)
Â  Â  const statusP1Range = paginaPrincipal.getRange(linhaInicial, 4, numLinhas, 1);
Â  Â  // Range de Status na P2 (Linha 2, Coluna 4, NumLinhas, 1 Coluna)
Â  Â  const statusP2Range = paginaCorrecoes.getRange(linhaInicial, 4, numLinhas, 1);
Â  Â  
Â  Â  // Le o Status final da P1
Â  Â  const statusP1Values = statusP1Range.getValues();
Â  Â  
Â  Â  // Escreve o Status final na P2
Â  Â  statusP2Range.setValues(statusP1Values);
Â  Â  
Â  Â  Logger.log("ğŸ”„ Status da PÃ¡gina de CorreÃ§Ãµes atualizado com base na PÃ¡gina Principal.");
Â  }
Â  
Â  SpreadsheetApp.flush(); // Flush final para garantir que o P2 Status foi escrito.
Â  if (!skipUI) ui.alert('âœ… CorreÃ§Ãµes Salvas!', 
Â  Â  `Foram salvas ${alteracoes.length} alteraÃ§Ãµes na aba "${CONFIG.ABAS.CORRECOES_MANUAIS}" e o histÃ³rico foi registrado em comentÃ¡rios.\n\n` +
Â  Â  'O Status do aluno foi sincronizado e as correÃ§Ãµes foram aplicadas Ã  PÃ¡gina 1.',
Â  Â  ui.ButtonSet.OK
Â  );
Â  Logger.log(`ğŸ’¾ ${alteracoes.length} correÃ§Ãµes manuais salvas e histÃ³rico adicionado em comentÃ¡rios.`);
}

// FUNÃ‡ÃƒO PARA LIMPAR COLUNAS DUPLICADAS EXISTENTES
function limparColunasDuplicadas(CONFIG) {
Â  const ss = SpreadsheetApp.getActiveSpreadsheet();
Â  const listaSheet = ss.getSheetByName(CONFIG.ABAS.LISTA_ALUNOS);
Â  const dados = listaSheet.getDataRange().getValues();
Â  const header = dados[0];
Â  
Â  const datasVistas = new Set();
Â  const colunasParaManter = [];
Â  const colunasParaRemover = [];
Â  
Â  // Identifica duplicatas (da esquerda para direita, mantendo a primeira ocorrÃªncia)
Â  for (let i = 0; i < header.length; i++) {
Â  Â  const dataHeader = header[i];
Â  Â  if (i < 4) {
Â  Â  Â  // MantÃ©m as primeiras 4 colunas fixas
Â  Â  Â  colunasParaManter.push(i);
Â  Â  Â  continue;
Â  Â  }
Â  Â  
Â  Â  const headerStr = String(dataHeader);
Â  Â  const dataBaseMatch = headerStr.match(/^(\d{1,2}\/\d{1,2}\/\d{4})( - \d+)?$/);
Â  Â  
Â  Â  if (dataBaseMatch) {
Â  Â  Â  const dataKey = dataBaseMatch[1] + (dataBaseMatch[2] || ' - 1');
Â  Â  Â  
Â  Â  Â  if (!datasVistas.has(dataKey)) {
Â  Â  Â  Â  datasVistas.add(dataKey);
Â  Â  Â  Â  colunasParaManter.push(i);
Â  Â  Â  } else {
Â  Â  Â  Â  colunasParaRemover.push(i);
Â  Â  Â  }
Â  Â  } else {
Â  Â  Â  colunasParaManter.push(i);
Â  Â  }
Â  }
Â  
Â  // Remove colunas duplicadas (da direita para esquerda)
Â  colunasParaRemover.sort((a, b) => b - a).forEach(colIndex => {
Â  Â  listaSheet.deleteColumn(colIndex + 1);
Â  });
Â  
Â  Logger.log(`âœ… Removidas ${colunasParaRemover.length} colunas duplicadas`);
Â  Logger.log(`ğŸ“Š Total de colunas mantidas: ${colunasParaManter.length}`);
Â  
Â  return colunasParaRemover.length;
}